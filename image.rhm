;; TODO: add more tests        
#lang rhombus

import: pict as p
        pict/radial as pr
        draw
        rhombus/rx open
        lib("racket/gui/base.rkt") : expose #{image-snip%} as img_snip
        lib("racket/class.rkt") : expose #{is-a?} as rkt_is_a
        "image-helper.rkt" as ih
        
export: mode_to_color
        circle
        //ellipse
        //line
        text
        triangle
        //square
        rectangle
        //rhombus
        //star
        overlay
        //underlay
        beside
        above
        empty_scene
        place_image
        //scene_line
        //rotate
        scale
        //scale_xy
        //place_images
        //posn
        //beside_align
        //overlay_align
        //above_align
        rename:
          draw.Color as make_color // might need to modify this later


fun to_pict(image):
  if image is_a p.Pict
  | image
  | if rkt_is_a(image, img_snip)
    | p.Pict.from_handle(ih.img_snip_to_pict(image))
    | error("expected a picture")
    /*
    | error(~who: to_string(fun_id),
            "expects a picture as " ++ index ++ " argument",
            ~details: ["given:",image])
    */


fun mode_to_color(mode):
  cond
  | mode == "solid": [#'inherit,1]
  | mode == "outline": [#false,1]
  | mode is_a Number: mode :: Real.in(0,255 ~inclusive)
                      [#'inherit,mode/255]
  | ~else: error(~who: #'mode_to_color,
                 "expects a mode as second argument",
                 ~details: ["given:",mode])


fun circle(radius :: NonnegReal, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  p.circle(~size:radius * 2, ~fill: md[0]).colorize(color).alpha(md[1])


fun ellipse(width :: NonnegReal, height :: NonnegReal, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  p.ellipse(~width:width,~height:height,~fill:md[0]).colorize(color).alpha(md[1])


fun line(x1, y1, clr):
  p.line(~dx: x1, ~dy: y1, ~line: clr)


fun string_to_list(s):
  def x = List.map(s , fun(x): string_to_list_helper(x))
  def y = for List ( z : x):
    cond
    |z.length() == 0: [] ++ [""]
    | ~else: z
  y


fun string_to_list_helper(s):
  cond
  | s.length() == 0: []
  | ~else: [s.substring(0,1)] ++ string_to_list_helper(s.substring(1..))


fun text(string :: String, font_size ::  Real.in(1, 255 ~inclusive), color :: String || draw.Color ):
  def list_of_words = rx'"\n"'.split(string)
  def lists_of_chars = string_to_list(list_of_words)
  def str1 = for List (x : lists_of_chars):
    def str2 = for List ( y : x) :
      p.text(y,~font:draw.Font(~kind: draw.Font.Kind.swiss,~size:font_size)).colorize(color)
    p.beside(~vert: #'baseline,&str2)
  p.stack(~horiz:#'left,& str1)

  
fun triangle(side_len :: NonnegReal, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  def h = math.round(side_len * math.sqrt(3)/2)
  p.polygon([[side_len/2,0], [side_len,h], [0,h]], ~fill: md[0]).colorize(color).alpha(md[1])


fun square(side_len :: NonnegReal, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  p.square(~size:side_len, ~fill: md[0]).colorize(color).alpha(md[1])


fun rectangle(width :: NonnegReal, height :: NonnegReal, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  p.rectangle(~width:width, ~height:height, ~fill:md[0]).colorize(color).alpha(md[1])


fun rhombus(side_length :: NonnegReal, angle :: Number, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  def new_angle = angle/2
  def opposite_angle = ((180 - angle) / 2) * math.pi / 180
  def h = math.round(2 * math.sin(opposite_angle) * side_length)
  def w = math.round(2 * math.cos(opposite_angle) * side_length)
  p.polygon([[0,h/2], [w/2,0],[w,h/2], [w/2, h]], ~fill: md[0]).colorize(color).alpha(md[1])


fun star(side_length :: Number, mode, color :: String || draw.Color):
  def md = mode_to_color(mode)
  def angle = 36 * math.pi / 180
  def Rc = side_length / (2 * math.sin(angle))
  def Ri = side_length / (2 * math.tan(angle))
  def h = math.round(Rc + Ri)
  def w = math.round(side_length + 2 * side_length  * math.cos(2 * angle))
  pr.star(~points: 5, ~width: w, ~height: h,~fill: md[0]).colorize(color).alpha(md[1])

  
fun overlay(x, y, z,...):
  p.overlay(~order:#'back,to_pict(x), to_pict(y), to_pict(z), ...)


fun underlay(x :: p.Pict,...): 
  p.overlay(~order:#'front,x,...)


fun beside(x, y, z, ...): 
  p.beside(to_pict(x), to_pict(y), to_pict(z), ...)


fun above(x :: p.Pict,...):
  p.stack(x,...)


fun empty_scene(width :: NonnegReal, height :: NonnegReal):
  p.rectangle(~width:width, ~height:height, ~fill:"white",~line:"black")


fun place_image(image, x :: Real, y :: Real, scene):
  def new_scene = to_pict(scene)
  def new_img = to_pict(image)
  p.pin(~on: new_scene, ~at: p.Find.left_top(new_scene,~dx:x,~dy:y),~pinhole: p.Find.center(new_img),new_img).clip()


fun scene_line(image :: p.Pict, x1 :: Real, y1 :: Real, x2 :: Real, y2 :: Real, clr):
  def ln = line(x2-x1,y2-y1,clr)
  p.pin(~on: image,~at: p.Find.left_top(image,~dx:x1,~dy:y1),~pinhole: p.Find.left_top(ln),ln).clip() 


fun rotate(angle :: Number, image :: p.Pict): // rotate extends the bounding box
  image.rotate(angle * math.pi/180)


fun scale(n :: NonnegReal, image):
  to_pict(image).scale(n)


fun scale_xy(x :: NonnegReal, y :: NonnegReal, image :: p.Pict):
  image.scale(x,y)


class posn(x,y)


fun place_images(i :: List.of(p.Pict), p :: List.of(posn), scene :: p.Pict):
  match i
  | []: scene
  | ~else: place_images(List.rest(i),List.rest(p), place_image(i[0],p[0].x,p[0].y,scene))

//did not do pinhole here so ask about it
// middle and center ==
// topline
// "top", "bottom", "middle", "center", "baseline", "pinhole".
fun y_place(x):
  if x in {"top", "topline", "center", "baseline", "bottom"}
  | Symbol.from_string(x)
  | "return error" //todo

//missing arg?
fun beside_align(y, x1 :: p.Pict, x2 :: p.Pict, x3 :: p.Pict, ...):
  p.beside(~vert: y_place(y), x1,x2,x3,...)

//did not do pinhole here so ask about it
// "left", "right", "middle" == "center", "".
fun x_place(x):                        
  cond
  | x == "left": #'left
  | x == "center" || x == "middle": #'center
  | x == "right": #'right
  | ~else : "error"


// overlay must expect at least 2 args
fun overlay_align(xplace,yplace,i1 :: p.Pict,i2 :: p.Pict, i3 :: p.Pict, ...):
  p.overlay(~horiz: x_place(xplace), ~vert: y_place(yplace), ~order:#'back, i1,i2,i3, ...)


fun above_align(xplace,i1 :: p.Pict,i2 :: p.Pict, i3 :: p.Pict, ...):
  p.stack(~horiz: x_place(xplace),i1,i2,i3,...)